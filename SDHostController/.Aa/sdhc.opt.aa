$pipe  DAT0Rx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT0Tx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT1Rx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT1Tx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT2Rx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT2Tx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT3Rx : $uint<1>  $depth 5 
// can point into 
$pipe  DAT3Tx : $uint<1>  $depth 5 
// can point into 
$constant  ONE_1 : $uint<1>:= 1  
$constant  ONE_2 : $uint<2>:= 1  
$constant  ONE_8 : $uint<8>:= 1  
$pipe  SDHC_to_IRC_INT : $uint<1>  $depth 1  $out  $signal 
// can point into 
$constant  ZERO_1 : $uint<1>:= 0  
$constant  ZERO_16 : $uint<16>:= 0  
$constant  ZERO_2 : $uint<2>:= 0  
$constant  ZERO_32 : $uint<32>:= 0  
$constant  ZERO_8 : $uint<8>:= 0  
$pipe  bigResponseEnable : $uint<1>  $depth 1  $out  $signal 
// can point into 
$pipe  busy : $uint<1>  $depth 1  $out  $signal 
// can point into 
$pipe  busyResponse : $uint<1>  $depth 1  $out  $signal 
// can point into 
$pipe  clkStable : $uint<1>  $depth 1  $in  $signal 
// can point into 
$pipe  commandTx : $uint<1>  $depth 48 
// can point into 
$pipe  dataBufferRx : $uint<8>  $depth 512 
// can point into 
$pipe  dataBufferTx : $uint<8>  $depth 512 
// can point into 
$storage  dataErrorInterruptStatus : $uint<8> // memory space index = 0  base address = 0  word size = 8
// can point into 
$storage  dataRxEnrty1 : $uint<1> // memory space index = 1  base address = 0  word size = 1
// can point into 
$storage  dataRxEnrty2 : $uint<1> // memory space index = 2  base address = 0  word size = 1
// can point into 
$pipe  dummy : $uint<1>  $depth 1 
// can point into 
$storage  errorInterruptFlag1 : $uint<8> // memory space index = 3  base address = 0  word size = 8
// can point into 
$storage  errorInterruptFlag2 : $uint<8> // memory space index = 4  base address = 0  word size = 8
// can point into 
$pipe  frequencySelect : $uint<20>  $depth 1  $out  $signal 
// can point into 
$pipe  in_data : $uint<8>  $depth 16 
// can point into 
$storage  normalInterruptFlag1 : $uint<8> // memory space index = 5  base address = 0  word size = 8
// can point into 
$storage  normalInterruptFlag2 : $uint<8> // memory space index = 6  base address = 0  word size = 8
// can point into 
$pipe  oe : $uint<1>  $depth 1  $out  $signal 
// can point into 
$pipe  out_data : $uint<8>  $depth 8 
// can point into 
$pipe  peripheral_bridge_to_sdhc_request : $uint<64>  $depth 1 
// can point into 
$pipe  ready : $uint<1>  $depth 1  $in  $signal 
// can point into 
$pipe  ready8clocks : $uint<1>  $depth 1  $in  $signal 
// can point into 
$pipe  readyClockCountEnable : $uint<1>  $depth 1  $out  $signal 
// can point into 
$pipe  responseEnable : $uint<1>  $depth 1  $out  $signal 
// can point into 
$pipe  responseRx : $uint<1>  $depth 4 
// can point into 
$storage  rxBufferPointer : $uint<10> // memory space index = 7  base address = 0  word size = 10
// can point into 
$pipe  sdClkEnable : $uint<1>  $depth 1  $out  $signal 
// can point into 
$storage  sdhcRegisters : $array[72] $of $uint<8> // memory space index = 8  base address = 0  word size = 8
// can point into 
$pipe  sdhc_to_peripheral_bridge_response : $uint<32>  $depth 1 
// can point into 
$storage  txBufferPointer : $uint<10> // memory space index = 9  base address = 0  word size = 10
// can point into 
$module [readSDHCRegisters]
$in ( address : $uint<8>  )
$out ( data : $uint<8>  )
$is
{
  data := sdhcRegisters[address] $buffering 1// bits of buffering = 8. 
}
$module [writeSDHCRegisters]
$in ( address : $uint<8>   data : $uint<8>  )
$out ()
$is
{
  sdhcRegisters[address] := data $buffering 1// bits of buffering = 8. 
}
$module [RW1C]
$in ( data : $uint<8>   address : $uint<8>  )
$out ()
$is
{
  $call readSDHCRegisters (address ) (current_data ) 
  $branchblock [rw1c]
  {
    $volatile d7 := ( $slice data 7 7 )  $buffering 1
    $volatile d6 := ( $slice data 6 6 )  $buffering 1
    $volatile d5 := ( $slice data 5 5 )  $buffering 1
    $volatile d4 := ( $slice data 4 4 )  $buffering 1
    $volatile d3 := ( $slice data 3 3 )  $buffering 1
    $volatile d2 := ( $slice data 2 2 )  $buffering 1
    $volatile d1 := ( $slice data 1 1 )  $buffering 1
    $volatile d0 := ( $slice data 0 0 )  $buffering 1
    $volatile current_d7 := ( $slice current_data 7 7 )  $buffering 1
    $volatile current_d6 := ( $slice current_data 6 6 )  $buffering 1
    $volatile current_d5 := ( $slice current_data 5 5 )  $buffering 1
    $volatile current_d4 := ( $slice current_data 4 4 )  $buffering 1
    $volatile current_d3 := ( $slice current_data 3 3 )  $buffering 1
    $volatile current_d2 := ( $slice current_data 2 2 )  $buffering 1
    $volatile current_d1 := ( $slice current_data 1 1 )  $buffering 1
    $volatile current_d0 := ( $slice current_data 0 0 )  $buffering 1
    $volatile b0 := ( $mux d0 ZERO_1  current_d0 )  $buffering 1
    $volatile b1 := ( $mux d1 ZERO_1  current_d1 )  $buffering 1
    $volatile b2 := ( $mux d2 ZERO_1  current_d2 )  $buffering 1
    $volatile b3 := ( $mux d3 ZERO_1  current_d3 )  $buffering 1
    $volatile b4 := ( $mux d4 ZERO_1  current_d4 )  $buffering 1
    $volatile b5 := ( $mux d5 ZERO_1  current_d5 )  $buffering 1
    $volatile b6 := ( $mux d6 ZERO_1  current_d6 )  $buffering 1
    $volatile b7 := ( $mux d7 ZERO_1  current_d7 )  $buffering 1
    $call writeSDHCRegisters (address (((b7 && b6) && (b5 && b4)) && ((b3 && b2) && (b1 && b0))) ) () 
    $if (address == 48 ) $then 
    normalInterruptFlag1 := (( ~ data ) & normalInterruptFlag1) $buffering 1// bits of buffering = 8. 
    $endif
    $if (address == 49 ) $then 
    normalInterruptFlag2 := (( ~ data ) & normalInterruptFlag2) $buffering 1// bits of buffering = 8. 
    $endif
    $if (address == 50 ) $then 
    errorInterruptFlag1 := (( ~ data ) & errorInterruptFlag1) $buffering 1// bits of buffering = 8. 
    $endif
    $if (address == 51 ) $then 
    errorInterruptFlag2 := (( ~ data ) & errorInterruptFlag2) $buffering 1// bits of buffering = 8. 
    $endif
  }
}
$module [generate_crc_7]
$in ( message_signal : $uint<40>  )
$out ( generated_crc : $uint<7>  )
$is
{
  $branchblock [loop]
  {
    $merge $entry loopback 
    $phi I := 			  next_I $on   loopback 			  ($bitcast ($uint<6>) 41  ) $on   $entry 
    // type of target is $uint<6>
    $phi crc_out := 			  final_crc_out $on   loopback 			  ( $slice message_signal 39 33 )  $on   $entry 
    // type of target is $uint<7>
    $phi temp := 			  next_temp $on   loopback 			  ( $slice message_signal 32 0 )  $on   $entry 
    // type of target is $uint<33>
    $endmerge
    $if ((crc_out [] 6 ) == 1 ) $then 
    $volatile a := (crc_out [] 5 ) $buffering 1
    $volatile b := (crc_out [] 4 ) $buffering 1
    $volatile c := (crc_out [] 3 ) $buffering 1
    $volatile d := ((crc_out [] 2 ) ^ 1 ) $buffering 1
    $volatile e := (crc_out [] 1 ) $buffering 1
    $volatile f := (crc_out [] 0 ) $buffering 1
    $volatile g := ((temp [] 32 ) ^ 1 ) $buffering 1
    $volatile crc_out_true := (((a && b) && (c && d)) && ((e && f) && g)) $buffering 1
    $place[MSB_true]
    $else 
    $volatile crc_out_false := (( $slice crc_out 5 0 )  && (temp [] 32 )) $buffering 1
    $place[MSB_false]
    $endif
    $merge MSB_true MSB_false 
    $phi final_crc_out := 			  crc_out_true $on   MSB_true 			  crc_out_false $on   MSB_false 
    // type of target is $uint<7>
    $endmerge
    $volatile next_I := (I - 1 ) $buffering 1
    $volatile next_temp := (temp << 1 ) $buffering 1
    $if (next_I > 0 ) $then 
    $place[loopback]
    $endif
  }
  ( crc_out => crc_out )
  generated_crc := crc_out $buffering 1// bits of buffering = 7. 
}
$module [generate_crc_7_120]
$in ( message_signal : $uint<120>  )
$out ( generated_crc : $uint<7>  )
$is
{
  $branchblock [loop]
  {
    $merge $entry loopback 
    $phi I := 			  ($bitcast ($uint<8>) 121  ) $on   $entry 			  next_I $on   loopback 
    // type of target is $uint<8>
    $phi crc_out := 			  ( $slice message_signal 119 113 )  $on   $entry 			  final_crc_out $on   loopback 
    // type of target is $uint<7>
    $phi temp := 			  ( $slice message_signal 112 0 )  $on   $entry 			  next_temp $on   loopback 
    // type of target is $uint<113>
    $endmerge
    $if ((crc_out [] 6 ) == 1 ) $then 
    $volatile a := (crc_out [] 5 ) $buffering 1
    $volatile b := (crc_out [] 4 ) $buffering 1
    $volatile c := (crc_out [] 3 ) $buffering 1
    $volatile d := ((crc_out [] 2 ) ^ 1 ) $buffering 1
    $volatile e := (crc_out [] 1 ) $buffering 1
    $volatile f := (crc_out [] 0 ) $buffering 1
    $volatile g := ((temp [] 112 ) ^ 1 ) $buffering 1
    $volatile crc_out_true := (((a && b) && (c && d)) && ((e && f) && g)) $buffering 1
    $place[MSB_true]
    $else 
    $volatile crc_out_false := (( $slice crc_out 5 0 )  && (temp [] 112 )) $buffering 1
    $place[MSB_false]
    $endif
    $merge MSB_true MSB_false 
    $phi final_crc_out := 			  crc_out_true $on   MSB_true 			  crc_out_false $on   MSB_false 
    // type of target is $uint<7>
    $endmerge
    $volatile next_I := (I - 1 ) $buffering 1
    $volatile next_temp := (temp << 1 ) $buffering 1
    $if (next_I > 0 ) $then 
    $place[loopback]
    $endif
  }
  ( crc_out => crc_out )
  generated_crc := crc_out $buffering 1// bits of buffering = 7. 
}
$module [recvdat0]
$in ()
$out ( dat0 : $uint<1024>   nextCRC_0 : $uint<16>   stopBit0 : $uint<1>  )
$is
{
  $branchblock [parallelblock_1]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi I_0 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_I_0 $on   $loopback 
    // type of target is $uint<11>
    $phi dat0_t := 			  ($bitcast ($uint<1042>) 0  ) $on   $entry 			  next_data0 $on   $loopback 
    // type of target is $uint<1042>
    $endmerge
    next_data0 := ((dat0_t << 1 ) | (($bitcast ($uint<1041>) 0  ) && DAT0Rx)) $buffering 1// bits of buffering = 1042. 
    $volatile next_I_0 := (I_0 + 1 ) $buffering 1
    $while (next_I_0 < 1042 )
    $volatile dat0 := ( $slice next_data0 1040 17 )  $buffering 1
    $volatile nextCRC_0 := ( $slice next_data0 16 1 )  $buffering 1
    $volatile stopBit0 := ( $slice next_data0 0 0 )  $buffering 1
  }
}
$module [recvdat1]
$in ()
$out ( dat1 : $uint<1024>   nextCRC_1 : $uint<16>   stopBit1 : $uint<1>  )
$is
{
  $branchblock [parallelblock_2]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi I_1 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_I_1 $on   $loopback 
    // type of target is $uint<11>
    $phi dat1_t := 			  ($bitcast ($uint<1042>) 0  ) $on   $entry 			  next_data1 $on   $loopback 
    // type of target is $uint<1042>
    $endmerge
    next_data1 := ((dat1_t << 1 ) | (($bitcast ($uint<1041>) 0  ) && DAT1Rx)) $buffering 1// bits of buffering = 1042. 
    $volatile next_I_1 := (I_1 + 1 ) $buffering 1
    $while (next_I_1 < 1042 )
    $volatile dat1 := ( $slice next_data1 1040 17 )  $buffering 1
    $volatile nextCRC_1 := ( $slice next_data1 16 1 )  $buffering 1
    $volatile stopBit1 := ( $slice next_data1 0 0 )  $buffering 1
  }
}
$module [recvdat2]
$in ()
$out ( dat2 : $uint<1024>   nextCRC_2 : $uint<16>   stopBit2 : $uint<1>  )
$is
{
  $branchblock [parallelblock_3]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi I_2 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_I_2 $on   $loopback 
    // type of target is $uint<11>
    $phi dat2_t := 			  ($bitcast ($uint<1042>) 0  ) $on   $entry 			  next_data2 $on   $loopback 
    // type of target is $uint<1042>
    $endmerge
    next_data2 := ((dat2_t << 1 ) | (($bitcast ($uint<1041>) 0  ) && DAT2Rx)) $buffering 1// bits of buffering = 1042. 
    $volatile next_I_2 := (I_2 + 1 ) $buffering 1
    $while (next_I_2 < 1042 )
    $volatile dat2 := ( $slice next_data2 1040 17 )  $buffering 1
    $volatile nextCRC_2 := ( $slice next_data2 16 1 )  $buffering 1
    $volatile stopBit2 := ( $slice next_data2 0 0 )  $buffering 1
  }
}
$module [recvdat3]
$in ()
$out ( dat3 : $uint<1024>   nextCRC_3 : $uint<16>   stopBit3 : $uint<1>  )
$is
{
  $branchblock [parallelblock_4]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi I_3 := 			  next_I_3 $on   $loopback 			  ($bitcast ($uint<11>) 0  ) $on   $entry 
    // type of target is $uint<11>
    $phi dat3_t := 			  ($bitcast ($uint<1042>) 0  ) $on   $entry 			  next_data3 $on   $loopback 
    // type of target is $uint<1042>
    $endmerge
    next_data3 := ((dat3_t << 1 ) | (($bitcast ($uint<1041>) 0  ) && DAT3Rx)) $buffering 1// bits of buffering = 1042. 
    $volatile next_I_3 := (I_3 + 1 ) $buffering 1
    $while (next_I_3 < 1042 )
    $volatile dat3 := ( $slice next_data3 1040 17 )  $buffering 1
    $volatile nextCRC_3 := ( $slice next_data3 16 1 )  $buffering 1
    $volatile stopBit3 := ( $slice next_data3 0 0 )  $buffering 1
  }
}
$module [dataRx]
$in ( singleMultipleReadBlock : $uint<1>  )
$out ( dataErrorInterruptStatusVar1 : $uint<8>  )
$is
{
  $branchblock [data_rx]
  {
    presentState1Var := sdhcRegisters[37 ] $buffering 1// bits of buffering = 8. 
    presentState0Var := sdhcRegisters[36 ] $buffering 1// bits of buffering = 8. 
    $if (sdhcRegisters[40 ] [] 1 ) $then 
    $parallelblock[rcv]
    {
      $call recvdat0 () (dat0 nextCRC_0 stopBit0 ) 
      $call recvdat1 () (dat1 nextCRC_1 stopBit1 ) 
      $call recvdat2 () (dat2 nextCRC_2 stopBit2 ) 
      $call recvdat3 () (dat3 nextCRC_3 stopBit3 ) 
    }
    ( dat0 => dat0  dat1 => dat1  dat2 => dat2  dat3 => dat3  nextCRC_0 => nextCRC_0  nextCRC_1 => nextCRC_1  nextCRC_2 => nextCRC_2  nextCRC_3 => nextCRC_3  stopBit0 => stopBit0  stopBit1 => stopBit1  stopBit2 => stopBit2  stopBit3 => stopBit3 )
    $volatile stopBitError0 := (stopBit0 == 0 ) $buffering 1
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J_0 := 			  next_J_0 $on   $loopback 			  ($bitcast ($uint<13>) 0  ) $on   $entry 
    // type of target is $uint<13>
    $phi CRC_16_0 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_0 $on   $loopback 
    // type of target is $uint<16>
    $phi tempData0 := 			  dat0 $on   $entry 			  nextTempData0 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile inv0 := ((tempData0 [] 1023 ) ^ (CRC_16_0 [] 15 )) $buffering 1
    $volatile nextCRC16_0 := (((( $slice CRC_16_0 14 12 )  && ((CRC_16_0 [] 11 ) ^ inv0)) && ( $slice CRC_16_0 10 5 ) ) && ((((CRC_16_0 [] 4 ) ^ inv0) && ( $slice CRC_16_0 3 0 ) ) && inv0)) $buffering 1
    $volatile nextTempData0 := (tempData0 << 1 ) $buffering 1
    $volatile next_J_0 := (J_0 + 1 ) $buffering 1
    $while (next_J_0 < 1024 )
    $volatile crcError0 := (nextCRC_0 != nextCRC16_0) $buffering 1
    $volatile stopBitError1 := (stopBit1 == 0 ) $buffering 1
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J_1 := 			  ($bitcast ($uint<13>) 0  ) $on   $entry 			  next_J_1 $on   $loopback 
    // type of target is $uint<13>
    $phi CRC_16_1 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_1 $on   $loopback 
    // type of target is $uint<16>
    $phi tempData1 := 			  dat1 $on   $entry 			  nextTempData1 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile inv1 := ((tempData1 [] 1023 ) ^ (CRC_16_1 [] 15 )) $buffering 1
    $volatile nextCRC16_1 := (((( $slice CRC_16_1 14 12 )  && ((CRC_16_1 [] 11 ) ^ inv1)) && ( $slice CRC_16_1 10 5 ) ) && ((((CRC_16_1 [] 4 ) ^ inv1) && ( $slice CRC_16_1 3 0 ) ) && inv1)) $buffering 1
    $volatile nextTempData1 := (tempData1 << 1 ) $buffering 1
    $volatile next_J_1 := (J_1 + 1 ) $buffering 1
    $while (next_J_1 < 1024 )
    $volatile crcError1 := (nextCRC_1 != nextCRC16_1) $buffering 1
    $volatile stopBitError2 := (stopBit2 == 0 ) $buffering 1
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J_2 := 			  ($bitcast ($uint<13>) 0  ) $on   $entry 			  next_J_2 $on   $loopback 
    // type of target is $uint<13>
    $phi CRC_16_2 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_2 $on   $loopback 
    // type of target is $uint<16>
    $phi tempData2 := 			  dat2 $on   $entry 			  nextTempData2 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile inv2 := ((tempData2 [] 1023 ) ^ (CRC_16_2 [] 15 )) $buffering 1
    $volatile nextCRC16_2 := (((( $slice CRC_16_2 14 12 )  && ((CRC_16_2 [] 11 ) ^ inv2)) && ( $slice CRC_16_2 10 5 ) ) && ((((CRC_16_2 [] 4 ) ^ inv2) && ( $slice CRC_16_2 3 0 ) ) && inv2)) $buffering 1
    $volatile nextTempData2 := (tempData2 << 1 ) $buffering 1
    $volatile next_J_2 := (J_2 + 1 ) $buffering 1
    $while (next_J_2 < 1024 )
    $volatile crcError2 := (nextCRC_2 != nextCRC16_2) $buffering 1
    $volatile stopBitError3 := (stopBit3 == 0 ) $buffering 1
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J_3 := 			  ($bitcast ($uint<13>) 0  ) $on   $entry 			  next_J_3 $on   $loopback 
    // type of target is $uint<13>
    $phi CRC_16_3 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_3 $on   $loopback 
    // type of target is $uint<16>
    $phi tempData3 := 			  dat3 $on   $entry 			  nextTempData3 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile inv3 := ((tempData3 [] 1023 ) ^ (CRC_16_3 [] 15 )) $buffering 1
    $volatile nextCRC16_3 := (((( $slice CRC_16_3 14 12 )  && ((CRC_16_3 [] 11 ) ^ inv3)) && ( $slice CRC_16_3 10 5 ) ) && ((((CRC_16_3 [] 4 ) ^ inv3) && ( $slice CRC_16_3 3 0 ) ) && inv3)) $buffering 1
    $volatile nextTempData3 := (tempData3 << 1 ) $buffering 1
    $volatile next_J_3 := (J_3 + 1 ) $buffering 1
    $while (next_J_3 < 1024 )
    $volatile crcError3 := (nextCRC_3 != nextCRC16_3) $buffering 1
    rxBufferPointer := ($bitcast ($uint<10>) 512  ) $buffering 1// bits of buffering = 10. 
    $if (singleMultipleReadBlock == 0 ) $then 
    sdhcRegisters[36 ] := (presentState0Var & _hfb ) $buffering 1// bits of buffering = 8. 
    $endif
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi B := 			  ($bitcast ($uint<10>) 0  ) $on   $entry 			  next_B $on   $loopback 
    // type of target is $uint<10>
    $phi dataForBuffer0 := 			  dat0 $on   $entry 			  nextDataForBuffer0 $on   $loopback 
    // type of target is $uint<1024>
    $phi dataForBuffer1 := 			  dat1 $on   $entry 			  nextDataForBuffer1 $on   $loopback 
    // type of target is $uint<1024>
    $phi dataForBuffer2 := 			  dat2 $on   $entry 			  nextDataForBuffer2 $on   $loopback 
    // type of target is $uint<1024>
    $phi dataForBuffer3 := 			  dat3 $on   $entry 			  nextDataForBuffer3 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    dataBufferRx := ((((dataForBuffer3 [] 1023 ) && (dataForBuffer2 [] 1023 )) && ((dataForBuffer1 [] 1023 ) && (dataForBuffer0 [] 1023 ))) && (((dataForBuffer3 [] 1022 ) && (dataForBuffer2 [] 1022 )) && ((dataForBuffer1 [] 1022 ) && (dataForBuffer0 [] 1022 )))) $buffering 1// bits of buffering = 8. 
    $volatile nextDataForBuffer0 := (dataForBuffer0 << 2 ) $buffering 1
    $volatile nextDataForBuffer1 := (dataForBuffer1 << 2 ) $buffering 1
    $volatile nextDataForBuffer2 := (dataForBuffer2 << 2 ) $buffering 1
    $volatile nextDataForBuffer3 := (dataForBuffer3 << 2 ) $buffering 1
    $volatile next_B := (B + 1 ) $buffering 1
    $while (next_B < 512 )
    $volatile stopBitError_Final := ((stopBitError0 | stopBitError1) | (stopBitError2 | stopBitError3)) $buffering 1
    $volatile crcError_Final := ((crcError0 | crcError1) | (crcError2 | crcError3)) $buffering 1
    dataErrorInterruptStatusVar1_4 := (((ZERO_1 && stopBitError_Final) && crcError_Final) && ((ZERO_1 && ZERO_2) && ZERO_2)) $buffering 1// bits of buffering = 8. 
    $else 
    startBit := DAT0Rx $buffering 1// bits of buffering = 1. 
    $branchblock [dat_receive]
    {
      $merge $entry loopback1 
      $phi I := 					  ($bitcast ($uint<10>) 0  ) $on   $entry 					  next_I $on   loopback1 
      // type of target is $uint<10>
      $phi dat := 					  ($bitcast ($uint<4096>) 0  ) $on   $entry 					  next_data $on   loopback1 
      // type of target is $uint<4096>
      $endmerge
      bit7 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit6 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit5 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit4 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit3 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit2 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit1 := DAT0Rx $buffering 1// bits of buffering = 1. 
      bit0 := DAT0Rx $buffering 1// bits of buffering = 1. 
      dataBufferRx := (((bit7 && bit6) && (bit5 && bit4)) && ((bit3 && bit2) && (bit1 && bit0))) $buffering 1// bits of buffering = 8. 
      next_data := ((dat << 8 ) | (($bitcast ($uint<4088>) 0  ) && (((bit7 && bit6) && (bit5 && bit4)) && ((bit3 && bit2) && (bit1 && bit0))))) $buffering 1// bits of buffering = 4096. 
      next_I := (I + 1 ) $buffering 1// bits of buffering = 10. 
      $if (next_I < 512 ) $then 
      $place[loopback1]
      $endif
    }
    ( next_data => dat )
    rxBufferPointer := ($bitcast ($uint<10>) 512  ) $buffering 1// bits of buffering = 10. 
    $merge $entry crcloopback 
    $phi K := 				  ($bitcast ($uint<5>) 0  ) $on   $entry 				  next_K $on   crcloopback 
    // type of target is $uint<5>
    $phi currentCRC := 				  ($bitcast ($uint<16>) 0  ) $on   $entry 				  nextCRC $on   crcloopback 
    // type of target is $uint<16>
    $endmerge
    nextCRC := ((currentCRC << 1 ) | (($bitcast ($uint<15>) 0  ) && DAT0Rx)) $buffering 1// bits of buffering = 16. 
    next_K := (K + 1 ) $buffering 1// bits of buffering = 5. 
    $if (next_K < 16 ) $then 
    $place[crcloopback]
    $endif
    stopBit := DAT0Rx $buffering 1// bits of buffering = 1. 
    $if (singleMultipleReadBlock == 0 ) $then 
    sdhcRegisters[36 ] := (presentState0Var & _hfb ) $buffering 1// bits of buffering = 8. 
    $endif
    stopBitError := (stopBit == 0 ) $buffering 1// bits of buffering = 1. 
    $merge $entry loopback 
    $phi J := 				  ($bitcast ($uint<13>) 0  ) $on   $entry 				  next_J $on   loopback 
    // type of target is $uint<13>
    $phi CRC_16 := 				  ($bitcast ($uint<16>) 0  ) $on   $entry 				  nextCRC16 $on   loopback 
    // type of target is $uint<16>
    $phi tempData := 				  dat $on   $entry 				  nextTempData $on   loopback 
    // type of target is $uint<4096>
    $endmerge
    inv := ((tempData [] 4095 ) ^ (CRC_16 [] 15 )) $buffering 1// bits of buffering = 1. 
    nextCRC16 := (((( $slice CRC_16 14 12 )  && ((CRC_16 [] 11 ) ^ inv)) && ( $slice CRC_16 10 5 ) ) && ((((CRC_16 [] 4 ) ^ inv) && ( $slice CRC_16 3 0 ) ) && inv)) $buffering 1// bits of buffering = 16. 
    nextTempData := (tempData << 1 ) $buffering 1// bits of buffering = 4096. 
    $volatile next_J := (J + 1 ) $buffering 1
    $if (next_J < 4096 ) $then 
    $place[loopback]
    $endif
    crcError := (nextCRC != nextCRC16) $buffering 1// bits of buffering = 1. 
    dataErrorInterruptStatusVar1_0 := (((ZERO_1 && stopBitError) && crcError) && ((ZERO_1 && ZERO_2) && ZERO_2)) $buffering 1// bits of buffering = 8. 
    $endif
    dataErrorInterruptStatusVar1 := ( $mux (sdhcRegisters[40 ] [] 1 ) dataErrorInterruptStatusVar1_4  dataErrorInterruptStatusVar1_0 )  $buffering 1// bits of buffering = 8. 
    $if (singleMultipleReadBlock == 0 ) $then 
    sdhcRegisters[37 ] := (presentState1Var & _hfd ) $buffering 1// bits of buffering = 8. 
    sdhcRegisters[36 ] := (presentState0Var & _hfd ) $buffering 1// bits of buffering = 8. 
    $endif
    $report (You check 		 nextCRC16 nextCRC16 		 nextCRC nextCRC 		 rxBufferPointer rxBufferPointer )
  }
}
$module [command_generator]
$in ()
$out ( normalInterruptStatusVar1 : $uint<8>   normalInterruptStatusVar2 : $uint<8>   errorInterruptStatusVar1 : $uint<8>   errorInterruptStatusVar2 : $uint<8>   dataErrorInterruptStatusVar1 : $uint<8>   dataTransferComplete : $uint<8>  )
$is
{
  $branchblock [command]
  {
    $call readSDHCRegisters (14  ) (commandRegVal ) 
    $call readSDHCRegisters (15  ) (commandRegVal1 ) 
    $volatile tempVal := ((ZERO_32 && ZERO_1) && (ONE_1 && ( $slice commandRegVal1 5 0 ) )) $buffering 1
    $merge $entry loopcommand40bits 
    $phi C := 			  next_C $on   loopcommand40bits 			  ($bitcast ($uint<8>) 3  ) $on   $entry 
    // type of target is $uint<8>
    $phi newCommand40bits := 			  command40bits $on   loopcommand40bits 			  tempVal $on   $entry 
    // type of target is $uint<40>
    $endmerge
    $call readSDHCRegisters ((8  + C) ) (tempArgument ) 
    $volatile command40bits := (( $slice newCommand40bits 31 0 )  && tempArgument) $buffering 1
    $volatile next_C := (C - 1 ) $buffering 1
    $if (C != 0 ) $then 
    $place[loopcommand40bits]
    $endif
    $call generate_crc_7 (command40bits ) (crc7 ) 
    $volatile commandbits := ((command40bits && crc7) && ONE_1) $buffering 1
    oe := ONE_1 $buffering 1// bits of buffering = 1. 
    $branchblock [send_command]
    {
      $dopipeline $depth 7 $buffering 1
      $fullrate 
      $merge $entry $loopback 
      $phi J := 				  ZERO_8 $on   $entry 				  next_J $on   $loopback 
      // type of target is $uint<8>
      $phi old_commandbits := 				  commandbits $on   $entry 				  new_commandbits $on   $loopback 
      // type of target is $uint<48>
      $endmerge
      $volatile next_J := (J + 1 ) $buffering 1
      $volatile bit := ( $slice old_commandbits 47 47 )  $buffering 1
      commandTx := bit $buffering 1// bits of buffering = 1. 
      $volatile new_commandbits := (old_commandbits << 1 ) $buffering 1
      $while (next_J < 48 )
    }
    oe := ZERO_1 $buffering 1// bits of buffering = 1. 
    response_type := ( $slice commandRegVal 1 0 )  $buffering 1// bits of buffering = 2. 
    dataPresentSelect := (commandRegVal [] 5 ) $buffering 1// bits of buffering = 1. 
    $if (dataPresentSelect == 1 ) $then 
    $call readSDHCRegisters (12  ) (transferVal ) 
    txOrRX := (  $bitreduce |  (transferVal & _h10 ) ) $buffering 1// bits of buffering = 1. 
    $merge $entry loopPresent 
    $phi E := 				  ONE_8 $on   $entry 				  next_E $on   loopPresent 
    // type of target is $uint<8>
    $phi readNewPresent := 				  ($bitcast ($uint<16>) 0  ) $on   $entry 				  readPresentState $on   loopPresent 
    // type of target is $uint<16>
    $endmerge
    $call readSDHCRegisters ((36  + E) ) (readPresentStateTemp ) 
    $volatile readPresentState := (( $slice readNewPresent 7 0 )  && readPresentStateTemp) $buffering 1
    $volatile next_E := (E - 1 ) $buffering 1
    $if (E != 0 ) $then 
    $place[loopPresent]
    $endif
    $volatile presentState0Var := ( $slice readPresentState 7 0 )  $buffering 1
    $volatile presentState1Var := ( $slice readPresentState 15 8 )  $buffering 1
    $if (response_type != 3 ) $then 
    $volatile tempPstate := ( $mux txOrRX (presentState1Var | _h02 )  (presentState1Var | _h01 ) )  $buffering 1
    $call writeSDHCRegisters (37  tempPstate ) () 
    $endif
    $call writeSDHCRegisters (36  (presentState0Var | _h06 ) ) () 
    $endif
    $report (rsp resp 		 response_type response_type 		 dataPresentSelect dataPresentSelect )
    $if ((response_type == 2 ) | (response_type == 3 )) $then 
    responseEnable := ONE_1 $buffering 1// bits of buffering = 1. 
    $if (response_type == 3 ) $then 
    busyResponse := ONE_1 $buffering 1// bits of buffering = 1. 
    $endif
    $branchblock [receive_response]
    {
      $dopipeline $depth 5 $buffering 1
      $fullrate 
      $merge $entry $loopback 
      $phi J := 				  ($bitcast ($uint<6>) 0  ) $on   $entry 				  next_J $on   $loopback 
      // type of target is $uint<6>
      $phi old_responsebits := 				  ($bitcast ($uint<48>) 0  ) $on   $entry 				  new_responsebits $on   $loopback 
      // type of target is $uint<48>
      $endmerge
      $volatile next_J := (J + 1 ) $buffering 1
      responsebit := responseRx $buffering 1// bits of buffering = 1. 
      $volatile responsebits := (($bitcast ($uint<47>) 0  ) && responsebit) $buffering 1
      $volatile new_responsebits := ((old_responsebits << 1 ) | responsebits) $buffering 1
      $while (next_J < 48 )
    }
    ( new_responsebits => response )
    responseEnable := ZERO_1 $buffering 1// bits of buffering = 1. 
    $report (gen_comm f 			 response response )
    $if (response_type == 3 ) $then 
    $merge $entry waitloop 
    $endmerge
    wait := DAT0Rx $buffering 1// bits of buffering = 1. 
    $if (wait == ZERO_1) $then 
    $place[waitloop]
    $endif
    busyResponse := ZERO_1 $buffering 1// bits of buffering = 1. 
    $endif
    $if ((commandRegVal & _h8 ) == 8 ) $then 
    $call generate_crc_7 (( $slice response 47 8 )  ) (R1_6_7CRC ) 
    CommandCRCError := ( $mux (( $slice response 7 1 )  == R1_6_7CRC) _b00000000   _b00000010  )  $buffering 1// bits of buffering = 8. 
    $endif
    $if ((commandRegVal & _h10 ) == 16 ) $then 
    commandIndexCheck := (( $slice commandRegVal1 5 0 )  == ( $slice response 45 40 ) ) $buffering 1// bits of buffering = 1. 
    CommandIndexError := ( $mux commandIndexCheck _b00000000   _b00001000  )  $buffering 1// bits of buffering = 8. 
    $endif
    $merge $entry loopResponse 
    $phi R := 				  ZERO_8 $on   $entry 				  next_R $on   loopResponse 
    // type of target is $uint<8>
    $phi tempResponse := 				  ( $slice response 39 8 )  $on   $entry 				  nextResponse $on   loopResponse 
    // type of target is $uint<32>
    $endmerge
    $call writeSDHCRegisters ((16  + R) ( $slice tempResponse 7 0 )  ) () 
    $volatile nextResponse := (ZERO_8 && ( $slice tempResponse 31 8 ) ) $buffering 1
    $volatile next_R := (R + 1 ) $buffering 1
    $if (next_R < 4 ) $then 
    $place[loopResponse]
    $endif
    $call readSDHCRegisters (36  ) (tempPresentState2 ) 
    $volatile presentState2 := ((tempPresentState2 >> 1 ) << 1 ) $buffering 1
    $call readSDHCRegisters (48  ) (normalInterrupt2 ) 
    $call writeSDHCRegisters (36  presentState2 ) () 
    commandEndBitError := ( $mux (response [] 0 ) ZERO_8  ($bitcast ($uint<8>) 4  ) )  $buffering 1// bits of buffering = 8. 
    normalInterruptStatusVar_2 := (normalInterrupt2 | _h01 ) $buffering 1// bits of buffering = 8. 
    errorInterruptStatusVar_2 := ((CommandIndexError | CommandCRCError) | commandEndBitError) $buffering 1// bits of buffering = 8. 
    $place[normalInterruptResponse2]
    $else 
    $if (response_type == 1 ) $then 
    responseEnable := ONE_1 $buffering 1// bits of buffering = 1. 
    bigResponseEnable := ONE_1 $buffering 1// bits of buffering = 1. 
    $branchblock [receive_bigresponse]
    {
      $dopipeline $depth 10 $buffering 1
      $fullrate 
      $merge $entry $loopback 
      $phi J := 				  ($bitcast ($uint<8>) 0  ) $on   $entry 				  next_J $on   $loopback 
      // type of target is $uint<8>
      $phi old_bigresponsebits := 				  ($bitcast ($uint<136>) 0  ) $on   $entry 				  new_bigresponsebits $on   $loopback 
      // type of target is $uint<136>
      $endmerge
      $volatile next_J := (J + 1 ) $buffering 1
      bigresponsebit := responseRx $buffering 1// bits of buffering = 1. 
      $volatile bigresponsebits := (($bitcast ($uint<135>) 0  ) && bigresponsebit) $buffering 1
      $volatile new_bigresponsebits := ((old_bigresponsebits << 1 ) | bigresponsebits) $buffering 1
      $while (next_J < 136 )
    }
    ( new_bigresponsebits => bigResponse )
    responseEnable := ZERO_1 $buffering 1// bits of buffering = 1. 
    bigResponseEnable := ZERO_1 $buffering 1// bits of buffering = 1. 
    $report (gen_comm f 			 bigResponse bigResponse )
    $volatile CID_CRC := ( $slice bigResponse 7 1 )  $buffering 1
    $if ((commandRegVal & _h8 ) == 8 ) $then 
    $call generate_crc_7_120 (( $slice bigResponse 127 8 )  ) (R2_CRC ) 
    CommandCRCError1 := ( $mux (CID_CRC == R2_CRC) _b00000000   _b00000010  )  $buffering 1// bits of buffering = 8. 
    $endif
    commandEndBitError1 := ( $mux (bigResponse [] 0 ) ZERO_8  ($bitcast ($uint<8>) 4  ) )  $buffering 1// bits of buffering = 8. 
    errorInterruptStatusVar_3 := (CommandCRCError1 | commandEndBitError1) $buffering 1// bits of buffering = 8. 
    $branchblock [big_resp]
    {
      $dopipeline $depth 10 $buffering 1
      $fullrate 
      $merge $entry $loopback 
      $phi k := 				  ($bitcast ($uint<8>) 0  ) $on   $entry 				  next_k $on   $loopback 
      // type of target is $uint<8>
      $phi temp := 				  ( $slice bigResponse 127 8 )  $on   $entry 				  next_temp $on   $loopback 
      // type of target is $uint<120>
      $endmerge
      $volatile address := (16  + k) $buffering 1
      $call writeSDHCRegisters (address ( $slice temp 7 0 )  ) () 
      $volatile next_temp := (temp >> 8 ) $buffering 1
      $volatile next_k := (k + 1 ) $buffering 1
      $while (next_k < 15 )
    }
    $call readSDHCRegisters (36  ) (tempPresentState3 ) 
    presentState3 := ((tempPresentState3 >> 1 ) << 1 ) $buffering 1// bits of buffering = 8. 
    $call readSDHCRegisters (48  ) (normalInterrupt3 ) 
    $call writeSDHCRegisters (36  presentState3 ) () 
    normalInterruptStatusVar_3 := (normalInterrupt3 | _h01 ) $buffering 1// bits of buffering = 8. 
    $place[normalInterruptResponse3]
    $else 
    $if (response_type == 0 ) $then 
    $call readSDHCRegisters (36  ) (tempPresentState1 ) 
    $volatile presentState1 := ((tempPresentState1 >> 1 ) << 1 ) $buffering 1
    $call readSDHCRegisters (48  ) (normalInterrupt1 ) 
    $call writeSDHCRegisters (36  presentState1 ) () 
    $volatile normalInterruptStatusVar_1 := (normalInterrupt1 | _h01 ) $buffering 1
    $volatile errorInterruptStatusVar_1 := ZERO_8 $buffering 1
    $place[normalInterruptResponse1]
    $endif
    $endif
    $endif
    $merge normalInterruptResponse1 normalInterruptResponse2 normalInterruptResponse3 
    $phi normalInterruptStatusVar1 := 			  normalInterruptStatusVar_1 $on   normalInterruptResponse1 			  normalInterruptStatusVar_2 $on   normalInterruptResponse2 			  normalInterruptStatusVar_3 $on   normalInterruptResponse3 
    // type of target is $uint<8>
    $phi errorInterruptStatusVar1 := 			  errorInterruptStatusVar_1 $on   normalInterruptResponse1 			  errorInterruptStatusVar_2 $on   normalInterruptResponse2 			  errorInterruptStatusVar_3 $on   normalInterruptResponse3 
    // type of target is $uint<8>
    $endmerge
    $if (dataPresentSelect == 1 ) $then 
    $if ((txOrRX == 1 ) & (response_type != 3 )) $then 
    $call readSDHCRegisters (12  ) (tempTransfer ) 
    singleMultipleReadBlock := (  $bitreduce |  (tempTransfer & _h20 ) ) $buffering 1// bits of buffering = 1. 
    $call dataRx (singleMultipleReadBlock ) (dataErrorInterruptStatusVar1 ) 
    dataRxEnrty1 := ONE_1 $buffering 1// bits of buffering = 1. 
    dataRxEnrty2 := ZERO_1 $buffering 1// bits of buffering = 1. 
    transferCompleteData := ( $mux singleMultipleReadBlock ($bitcast ($uint<8>) 2  )  ZERO_8 )  $buffering 1// bits of buffering = 8. 
    $if (singleMultipleReadBlock == 1 ) $then 
    $merge $entry loopBlock1 
    $phi B := 				  next_B $on   loopBlock1 				  ONE_8 $on   $entry 
    // type of target is $uint<8>
    $phi readNewBlockCount := 				  readBlockCount $on   loopBlock1 				  ($bitcast ($uint<16>) 0  ) $on   $entry 
    // type of target is $uint<16>
    $endmerge
    $call readSDHCRegisters ((6  + B) ) (readnewBlockCountTemp ) 
    $volatile readBlockCount := (( $slice readNewBlockCount 7 0 )  && readnewBlockCountTemp) $buffering 1
    $volatile next_B := (B - 1 ) $buffering 1
    $if (B != 0 ) $then 
    $place[loopBlock1]
    $endif
    newReadBlockCount := (readBlockCount - 1 ) $buffering 1// bits of buffering = 16. 
    $call writeSDHCRegisters (7  ( $slice newReadBlockCount 15 8 )  ) () 
    $call writeSDHCRegisters (6  ( $slice newReadBlockCount 7 0 )  ) () 
    $endif
    $endif
    dataTransferComplete := ( $mux (response_type == 3 ) ($bitcast ($uint<8>) 2  )  transferCompleteData )  $buffering 1// bits of buffering = 8. 
    $endif
    normalInterruptStatusVar2 := ZERO_8 $buffering 1// bits of buffering = 8. 
    errorInterruptStatusVar2 := ZERO_8 $buffering 1// bits of buffering = 8. 
  }
}
$module [sendDAT0]
$in ( dat0 : $uint<1024>   nextCRC16_DAT0 : $uint<16>  )
$out ()
$is
{
  $branchblock [parallelblock_one]
  {
    newDat0 := ((ZERO_1 && dat0) && (nextCRC16_DAT0 && ONE_1)) $buffering 1// bits of buffering = 1042. 
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi k_0 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_k_0 $on   $loopback 
    // type of target is $uint<11>
    $phi dat0bit4_0 := 			  nextbit4_0 $on   $loopback 			  newDat0 $on   $entry 
    // type of target is $uint<1042>
    $endmerge
    DAT0Tx := (dat0bit4_0 [] 1041 ) $buffering 1// bits of buffering = 1. 
    $volatile nextbit4_0 := (dat0bit4_0 << 1 ) $buffering 1
    $volatile next_k_0 := (k_0 + 1 ) $buffering 1
    $while (next_k_0 < 1042 )
  }
}
$module [sendDAT1]
$in ( dat1 : $uint<1024>   nextCRC16_DAT1 : $uint<16>  )
$out ()
$is
{
  $branchblock [parallelblock_two]
  {
    newDat1 := ((ZERO_1 && dat1) && (nextCRC16_DAT1 && ONE_1)) $buffering 1// bits of buffering = 1042. 
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi k_1 := 			  next_k_1 $on   $loopback 			  ($bitcast ($uint<11>) 0  ) $on   $entry 
    // type of target is $uint<11>
    $phi dat0bit4_1 := 			  nextbit4_1 $on   $loopback 			  newDat1 $on   $entry 
    // type of target is $uint<1042>
    $endmerge
    DAT1Tx := (dat0bit4_1 [] 1041 ) $buffering 1// bits of buffering = 1. 
    $volatile nextbit4_1 := (dat0bit4_1 << 1 ) $buffering 1
    $volatile next_k_1 := (k_1 + 1 ) $buffering 1
    $while (next_k_1 < 1042 )
  }
}
$module [sendDAT2]
$in ( dat2 : $uint<1024>   nextCRC16_DAT2 : $uint<16>  )
$out ()
$is
{
  $branchblock [parallelblock_three]
  {
    newDat2 := ((ZERO_1 && dat2) && (nextCRC16_DAT2 && ONE_1)) $buffering 1// bits of buffering = 1042. 
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi k_2 := 			  next_k_2 $on   $loopback 			  ($bitcast ($uint<11>) 0  ) $on   $entry 
    // type of target is $uint<11>
    $phi dat0bit4_2 := 			  nextbit4_2 $on   $loopback 			  newDat2 $on   $entry 
    // type of target is $uint<1042>
    $endmerge
    DAT2Tx := (dat0bit4_2 [] 1041 ) $buffering 1// bits of buffering = 1. 
    $volatile nextbit4_2 := (dat0bit4_2 << 1 ) $buffering 1
    $volatile next_k_2 := (k_2 + 1 ) $buffering 1
    $while (next_k_2 < 1042 )
  }
}
$module [sendDAT3]
$in ( dat3 : $uint<1024>   nextCRC16_DAT3 : $uint<16>  )
$out ()
$is
{
  $branchblock [parallelblock_four]
  {
    newDat3 := ((ZERO_1 && dat3) && (nextCRC16_DAT3 && ONE_1)) $buffering 1// bits of buffering = 1042. 
    $dopipeline $depth 5 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi k_3 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_k_3 $on   $loopback 
    // type of target is $uint<11>
    $phi dat0bit4_3 := 			  newDat3 $on   $entry 			  nextbit4_3 $on   $loopback 
    // type of target is $uint<1042>
    $endmerge
    DAT3Tx := (dat0bit4_3 [] 1041 ) $buffering 1// bits of buffering = 1. 
    $volatile nextbit4_3 := (dat0bit4_3 << 1 ) $buffering 1
    $volatile next_k_3 := (k_3 + 1 ) $buffering 1
    $while (next_k_3 < 1042 )
  }
}
$module [dataTx]
$in ( lastBlock : $uint<1>   blockCountEnable : $uint<1>   blockCount : $uint<16>  )
$out ( blockCountNext : $uint<16>   transferComplete : $uint<8>  )
$is
{
  $branchblock [data]
  {
    $if (sdhcRegisters[40 ] [] 1 ) $then 
    $branchblock [dat_store_4]
    {
      $dopipeline $depth 10 $buffering 1
      $fullrate 
      $merge $entry $loopback 
      $phi i := 				  next_i $on   $loopback 				  ($bitcast ($uint<10>) 0  ) $on   $entry 
      // type of target is $uint<10>
      $phi dat0 := 				  next_data0 $on   $loopback 				  ($bitcast ($uint<1024>) 0  ) $on   $entry 
      // type of target is $uint<1024>
      $phi dat1 := 				  next_data1 $on   $loopback 				  ($bitcast ($uint<1024>) 0  ) $on   $entry 
      // type of target is $uint<1024>
      $phi dat2 := 				  next_data2 $on   $loopback 				  ($bitcast ($uint<1024>) 0  ) $on   $entry 
      // type of target is $uint<1024>
      $phi dat3 := 				  next_data3 $on   $loopback 				  ($bitcast ($uint<1024>) 0  ) $on   $entry 
      // type of target is $uint<1024>
      $endmerge
      tempBuffer := dataBufferTx $buffering 1// bits of buffering = 8. 
      $volatile next_data3 := ((dat3 << 2 ) | ((($bitcast ($uint<1022>) 0  ) && (tempBuffer [] 7 )) && (tempBuffer [] 3 ))) $buffering 1
      $volatile next_data2 := ((dat2 << 2 ) | ((($bitcast ($uint<1022>) 0  ) && (tempBuffer [] 6 )) && (tempBuffer [] 2 ))) $buffering 1
      $volatile next_data1 := ((dat1 << 2 ) | ((($bitcast ($uint<1022>) 0  ) && (tempBuffer [] 5 )) && (tempBuffer [] 1 ))) $buffering 1
      $volatile next_data0 := ((dat0 << 2 ) | ((($bitcast ($uint<1022>) 0  ) && (tempBuffer [] 4 )) && (tempBuffer [] 0 ))) $buffering 1
      $volatile next_i := (i + 1 ) $buffering 1
      $while (next_i < 512 )
    }
    ( next_data0 => dat0  next_data1 => dat1  next_data2 => dat2  next_data3 => dat3 )
    txBufferPointer := ($bitcast ($uint<10>) 0  ) $buffering 1// bits of buffering = 10. 
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi j_0 := 			  next_j_0 $on   $loopback 			  ($bitcast ($uint<11>) 0  ) $on   $entry 
    // type of target is $uint<11>
    $phi CRC_16_DAT0 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_DAT0 $on   $loopback 
    // type of target is $uint<16>
    $phi tempDataD0 := 			  nextTempDataD0 $on   $loopback 			  dat0 $on   $entry 
    // type of target is $uint<1024>
    $endmerge
    $volatile invd0 := ((tempDataD0 [] 1023 ) ^ (CRC_16_DAT0 [] 15 )) $buffering 1
    $volatile nextCRC16_DAT0 := (((( $slice CRC_16_DAT0 14 12 )  && ((CRC_16_DAT0 [] 11 ) ^ invd0)) && ( $slice CRC_16_DAT0 10 5 ) ) && ((((CRC_16_DAT0 [] 4 ) ^ invd0) && ( $slice CRC_16_DAT0 3 0 ) ) && invd0)) $buffering 1
    $volatile nextTempDataD0 := (tempDataD0 << 1 ) $buffering 1
    $volatile next_j_0 := (j_0 + 1 ) $buffering 1
    $while (next_j_0 < 1024 )
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi j_1 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_j_1 $on   $loopback 
    // type of target is $uint<11>
    $phi CRC_16_DAT1 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_DAT1 $on   $loopback 
    // type of target is $uint<16>
    $phi tempDataD1 := 			  dat1 $on   $entry 			  nextTempDataD1 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile invd1 := ((tempDataD1 [] 1023 ) ^ (CRC_16_DAT1 [] 15 )) $buffering 1
    $volatile nextCRC16_DAT1 := (((( $slice CRC_16_DAT1 14 12 )  && ((CRC_16_DAT1 [] 11 ) ^ invd1)) && ( $slice CRC_16_DAT1 10 5 ) ) && ((((CRC_16_DAT1 [] 4 ) ^ invd1) && ( $slice CRC_16_DAT1 3 0 ) ) && invd1)) $buffering 1
    $volatile nextTempDataD1 := (tempDataD1 << 1 ) $buffering 1
    $volatile next_j_1 := (j_1 + 1 ) $buffering 1
    $while (next_j_1 < 1024 )
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi j_2 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_j_2 $on   $loopback 
    // type of target is $uint<11>
    $phi CRC_16_DAT2 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_DAT2 $on   $loopback 
    // type of target is $uint<16>
    $phi tempDataD2 := 			  dat2 $on   $entry 			  nextTempDataD2 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile invd2 := ((tempDataD2 [] 1023 ) ^ (CRC_16_DAT2 [] 15 )) $buffering 1
    $volatile nextCRC16_DAT2 := (((( $slice CRC_16_DAT2 14 12 )  && ((CRC_16_DAT2 [] 11 ) ^ invd2)) && ( $slice CRC_16_DAT2 10 5 ) ) && ((((CRC_16_DAT2 [] 4 ) ^ invd2) && ( $slice CRC_16_DAT2 3 0 ) ) && invd2)) $buffering 1
    $volatile nextTempDataD2 := (tempDataD2 << 1 ) $buffering 1
    $volatile next_j_2 := (j_2 + 1 ) $buffering 1
    $while (next_j_2 < 1024 )
    $dopipeline $depth 10 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi j_3 := 			  ($bitcast ($uint<11>) 0  ) $on   $entry 			  next_j_3 $on   $loopback 
    // type of target is $uint<11>
    $phi CRC_16_DAT3 := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  nextCRC16_DAT3 $on   $loopback 
    // type of target is $uint<16>
    $phi tempDataD3 := 			  dat3 $on   $entry 			  nextTempDataD3 $on   $loopback 
    // type of target is $uint<1024>
    $endmerge
    $volatile invd3 := ((tempDataD3 [] 1023 ) ^ (CRC_16_DAT3 [] 15 )) $buffering 1
    $volatile nextCRC16_DAT3 := (((( $slice CRC_16_DAT3 14 12 )  && ((CRC_16_DAT3 [] 11 ) ^ invd3)) && ( $slice CRC_16_DAT3 10 5 ) ) && ((((CRC_16_DAT3 [] 4 ) ^ invd3) && ( $slice CRC_16_DAT3 3 0 ) ) && invd3)) $buffering 1
    $volatile nextTempDataD3 := (tempDataD3 << 1 ) $buffering 1
    $volatile next_j_3 := (j_3 + 1 ) $buffering 1
    $while (next_j_3 < 1024 )
    oe := ONE_1 $buffering 1// bits of buffering = 1. 
    $parallelblock[senddata]
    {
      $call sendDAT0 (dat0 nextCRC16_DAT0 ) () 
      $call sendDAT1 (dat1 nextCRC16_DAT1 ) () 
      $call sendDAT2 (dat2 nextCRC16_DAT2 ) () 
      $call sendDAT3 (dat3 nextCRC16_DAT3 ) () 
    }
    oe := ZERO_1 $buffering 1// bits of buffering = 1. 
    $else 
    $branchblock [dat_store]
    {
      $merge $entry loopback1 
      $phi I := 					  ($bitcast ($uint<10>) 0  ) $on   $entry 					  next_I $on   loopback1 
      // type of target is $uint<10>
      $phi dat := 					  ($bitcast ($uint<4096>) 0  ) $on   $entry 					  next_data $on   loopback1 
      // type of target is $uint<4096>
      $endmerge
      next_data := ((dat << 8 ) | (($bitcast ($uint<4088>) 0  ) && dataBufferTx)) $buffering 1// bits of buffering = 4096. 
      next_I := (I + 1 ) $buffering 1// bits of buffering = 10. 
      $if (next_I < 512 ) $then 
      $place[loopback1]
      $endif
    }
    ( next_data => dat )
    txBufferPointer := ($bitcast ($uint<10>) 0  ) $buffering 1// bits of buffering = 10. 
    $merge $entry loopback 
    $phi J := 				  ($bitcast ($uint<13>) 0  ) $on   $entry 				  next_J $on   loopback 
    // type of target is $uint<13>
    $phi CRC_16 := 				  ($bitcast ($uint<16>) 0  ) $on   $entry 				  nextCRC16 $on   loopback 
    // type of target is $uint<16>
    $phi tempData := 				  dat $on   $entry 				  nextTempData $on   loopback 
    // type of target is $uint<4096>
    $endmerge
    inv := ((tempData [] 4095 ) ^ (CRC_16 [] 15 )) $buffering 1// bits of buffering = 1. 
    nextCRC16 := (((( $slice CRC_16 14 12 )  && ((CRC_16 [] 11 ) ^ inv)) && ( $slice CRC_16 10 5 ) ) && ((((CRC_16 [] 4 ) ^ inv) && ( $slice CRC_16 3 0 ) ) && inv)) $buffering 1// bits of buffering = 16. 
    nextTempData := (tempData << 1 ) $buffering 1// bits of buffering = 4096. 
    $volatile next_J := (J + 1 ) $buffering 1
    $if (next_J < 4096 ) $then 
    $place[loopback]
    $endif
    $report (OUTDATA data 			 dat dat 			 nextCRC16 nextCRC16 			 lastBlock lastBlock )
    oe := ONE_1 $buffering 1// bits of buffering = 1. 
    DAT0Tx := ZERO_1 $buffering 1// bits of buffering = 1. 
    $merge $entry dataloop 
    $phi K := 				  ($bitcast ($uint<13>) 0  ) $on   $entry 				  next_K $on   dataloop 
    // type of target is $uint<13>
    $phi dat0bit := 				  dat $on   $entry 				  nextbit $on   dataloop 
    // type of target is $uint<4096>
    $endmerge
    DAT0Tx := (dat0bit [] 4095 ) $buffering 1// bits of buffering = 1. 
    nextbit := (dat0bit << 1 ) $buffering 1// bits of buffering = 4096. 
    next_K := (K + 1 ) $buffering 1// bits of buffering = 13. 
    $if (next_K < 4096 ) $then 
    $place[dataloop]
    $endif
    $merge $entry crcloop 
    $phi L := 				  ($bitcast ($uint<5>) 0  ) $on   $entry 				  next_L $on   crcloop 
    // type of target is $uint<5>
    $phi dat0crc := 				  nextCRC16 $on   $entry 				  nextbitcrc $on   crcloop 
    // type of target is $uint<16>
    $endmerge
    DAT0Tx := (dat0crc [] 15 ) $buffering 1// bits of buffering = 1. 
    nextbitcrc := (dat0crc << 1 ) $buffering 1// bits of buffering = 16. 
    next_L := (L + 1 ) $buffering 1// bits of buffering = 5. 
    $if (next_L < 16 ) $then 
    $place[crcloop]
    $endif
    DAT0Tx := ONE_1 $buffering 1// bits of buffering = 1. 
    oe := ZERO_1 $buffering 1// bits of buffering = 1. 
    $endif
    busy := ONE_1 $buffering 1// bits of buffering = 1. 
    $guard (blockCountEnable) blockCountNext := (blockCount - 1 ) $buffering 1// bits of buffering = 16. 
    $if (lastBlock == 1 ) $then 
    presentState1Var := sdhcRegisters[37 ] $buffering 1// bits of buffering = 8. 
    presentState0Var := sdhcRegisters[36 ] $buffering 1// bits of buffering = 8. 
    sdhcRegisters[37 ] := (presentState1Var & _hfe ) $buffering 1// bits of buffering = 8. 
    $endif
    $merge $entry waitloop 
    $endmerge
    wait := DAT0Rx $buffering 1// bits of buffering = 1. 
    $if (wait == ZERO_1) $then 
    $place[waitloop]
    $endif
    busy := ZERO_1 $buffering 1// bits of buffering = 1. 
    $if (lastBlock == 1 ) $then 
    sdhcRegisters[36 ] := (presentState0Var & _hf9 ) $buffering 1// bits of buffering = 8. 
    transferComplete := (ZERO_8 | _h02 ) $buffering 1// bits of buffering = 8. 
    $endif
    $report (OUTDATA data 		 lastBlock lastBlock 		 blockCount blockCount 		 blockCountEnable blockCountEnable )
  }
}
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$module [resetRegisters]
$in ( resetCondition : $uint<2>  )
$out ()
$is
{
  $call writeSDHCRegisters (64  _h8A  ) () 
  $call writeSDHCRegisters (65  _h64  ) () 
  $call writeSDHCRegisters (66  _h20  ) () 
  $call writeSDHCRegisters (67  _h05  ) () 
  $call writeSDHCRegisters (68  _h31  ) () 
  $call writeSDHCRegisters (69  ZERO_8 ) () 
  $call writeSDHCRegisters (70  ZERO_8 ) () 
  $call writeSDHCRegisters (71  ZERO_8 ) () 
  $call writeSDHCRegisters (45  _h7D  ) () 
  $branchblock [resetRegister]
  {
    $merge $entry loopback 
    $phi I := 			  ($bitcast ($uint<8>) 0  ) $on   $entry 			  next_I $on   loopback 
    // type of target is $uint<8>
    $endmerge
    $call readSDHCRegisters (I ) (current_register_value ) 
    $call readSDHCRegisters (47  ) (current_softwarereset_register_value ) 
    $volatile condition := ((I >= 64 ) & (I < 72 )) $buffering 1
    $volatile condition5 := (I == 45 ) $buffering 1
    $if (condition | condition5) $then 
    $null
    $else 
    $if (resetCondition == ZERO_2) $then 
    $call writeSDHCRegisters (I ZERO_8 ) () 
    $else 
    $if ((resetCondition == ONE_2) & ((I == 36 ) | (I == 48 ))) $then 
    $call writeSDHCRegisters (I (current_register_value & _hfe ) ) () 
    $else 
    $if (resetCondition == ($bitcast ($uint<2>) 2  )) $then 
    $if ((I >= 32 ) & (I < 36 )) $then 
    $call writeSDHCRegisters (I ZERO_8 ) () 
    $endif
    $if (I == 36 ) $then 
    $call writeSDHCRegisters (I (current_register_value & _h09 ) ) () 
    $endif
    $if (I == 37 ) $then 
    $call writeSDHCRegisters (I ZERO_8 ) () 
    $endif
    $if (I == 48 ) $then 
    $call writeSDHCRegisters (I (current_register_value & _hC1 ) ) () 
    $endif
    $endif
    $endif
    $endif
    $endif
    $volatile next_I := (I + 1 ) $buffering 1
    $if (next_I < 72 ) $then 
    $place[loopback]
    $endif
    $if (resetCondition == ONE_2) $then 
    $call writeSDHCRegisters (47  (current_softwarereset_register_value & _hfd ) ) () 
    $endif
    $if (resetCondition == ($bitcast ($uint<2>) 2  )) $then 
    $call writeSDHCRegisters (47  (current_softwarereset_register_value & _hfb ) ) () 
    $endif
  }
}
$module [sdhc_register_write]
$in ( address : $uint<8>   data : $uint<8>  )
$out ()
$is
{
  $branchblock [write_register]
  {
    $switch address
    $when 5  $then 
    $call writeSDHCRegisters (address (data & _h7f ) ) () 
    $when 12  $then 
    $call writeSDHCRegisters (address (data & _h3f ) ) () 
    $when 13  $then 
    $call writeSDHCRegisters (address ZERO_8 ) () 
    $when 14  $then 
    $call writeSDHCRegisters (address (data & _hfb ) ) () 
    $when 15  $then 
    $call writeSDHCRegisters (address (data & _h3f ) ) () 
    $when 16  $then 
    $null
    $when 17  $then 
    $null
    $when 18  $then 
    $null
    $when 19  $then 
    $null
    $when 20  $then 
    $null
    $when 21  $then 
    $null
    $when 22  $then 
    $null
    $when 23  $then 
    $null
    $when 24  $then 
    $null
    $when 25  $then 
    $null
    $when 26  $then 
    $null
    $when 27  $then 
    $null
    $when 28  $then 
    $null
    $when 29  $then 
    $null
    $when 30  $then 
    $null
    $when 31  $then 
    $null
    $when 36  $then 
    $null
    $when 37  $then 
    $null
    $when 38  $then 
    $null
    $when 39  $then 
    $null
    $when 44  $then 
    $call writeSDHCRegisters (address (data & _h05 ) ) () 
    $when 47  $then 
    $call writeSDHCRegisters (address (data & _h7 ) ) () 
    $when 48  $then 
    $call RW1C (data address ) () 
    $when 49  $then 
    $null
    $when 50  $then 
    $call RW1C (data address ) () 
    $when 51  $then 
    $call RW1C (data address ) () 
    $when 53  $then 
    $call writeSDHCRegisters (address (data & _h1f ) ) () 
    $when 55  $then 
    $call writeSDHCRegisters (address (data & _hf7 ) ) () 
    $when 57  $then 
    $call writeSDHCRegisters (address (data & _h1f ) ) () 
    $when 59  $then 
    $call writeSDHCRegisters (address (data & _hf7 ) ) () 
    $when 63  $then 
    $call writeSDHCRegisters (address (data & _hC0 ) ) () 
    $when 64  $then 
    $null
    $when 65  $then 
    $null
    $when 66  $then 
    $null
    $when 67  $then 
    $null
    $when 68  $then 
    $null
    $when 69  $then 
    $null
    $when 70  $then 
    $null
    $when 71  $then 
    $call writeSDHCRegisters (address ZERO_8 ) () 
    $default 
    $call writeSDHCRegisters (address data ) () 
    $endswitch 
  }
}
$module [sdhc_daemon]
$in ()
$out ()
$is
{
  SDHC_to_IRC_INT := ZERO_1 $buffering 1// bits of buffering = 1. 
  oe := ZERO_1 $buffering 1// bits of buffering = 1. 
  busy := ZERO_1 $buffering 1// bits of buffering = 1. 
  readyClockCountEnable := ONE_1 $buffering 1// bits of buffering = 1. 
  normalInterruptFlag1 := _hFF  $buffering 1// bits of buffering = 8. 
  normalInterruptFlag2 := _hFF  $buffering 1// bits of buffering = 8. 
  errorInterruptFlag1 := _hFF  $buffering 1// bits of buffering = 8. 
  errorInterruptFlag2 := _hFF  $buffering 1// bits of buffering = 8. 
  txBufferPointer := ($bitcast ($uint<10>) 0  ) $buffering 1// bits of buffering = 10. 
  rxBufferPointer := ($bitcast ($uint<10>) 0  ) $buffering 1// bits of buffering = 10. 
  dataRxEnrty1 := ZERO_1 $buffering 1// bits of buffering = 1. 
  dataRxEnrty2 := ZERO_1 $buffering 1// bits of buffering = 1. 
  dataErrorInterruptStatus := ZERO_8 $buffering 1// bits of buffering = 8. 
  $call resetRegisters (ZERO_2 ) () 
  $branchblock [loop]
  {
    $merge $entry loopback 
    $endmerge
    request := peripheral_bridge_to_sdhc_request $buffering 1// bits of buffering = 64. 
    $volatile rwbar := ( $slice request 63 63 )  $buffering 1
    $volatile bytemask := ( $slice request 62 59 )  $buffering 1
    $volatile address := ( $slice request 39 32 )  $buffering 1
    $volatile data3 := ( $slice request 31 24 )  $buffering 1
    $volatile data2 := ( $slice request 23 16 )  $buffering 1
    $volatile data1 := ( $slice request 15 8 )  $buffering 1
    $volatile data0 := ( $slice request 7 0 )  $buffering 1
    $volatile b3 := ( $slice bytemask 3 3 )  $buffering 1
    $volatile b2 := ( $slice bytemask 2 2 )  $buffering 1
    $volatile b1 := ( $slice bytemask 1 1 )  $buffering 1
    $volatile b0 := ( $slice bytemask 0 0 )  $buffering 1
    $if (rwbar == 0 ) $then 
    $guard (b3) $call sdhc_register_write (address data3 ) () 
    $guard (b2) $call sdhc_register_write ((address + 1 ) data2 ) () 
    $guard (b1) $call sdhc_register_write ((address + 2 ) data1 ) () 
    $guard (b0) $call sdhc_register_write ((address + 3 ) data0 ) () 
    sdhc_to_peripheral_bridge_response := ZERO_32 $buffering 1// bits of buffering = 32. 
    $if ((address + 3 ) == 47 ) $then 
    $call readSDHCRegisters (47  ) (softwareResetVal ) 
    $if (softwareResetVal [] 0 ) $then 
    $call resetRegisters (ZERO_2 ) () 
    $endif
    $if (softwareResetVal [] 1 ) $then 
    $call resetRegisters (ONE_2 ) () 
    $endif
    $if (softwareResetVal [] 2 ) $then 
    $call resetRegisters (($bitcast ($uint<2>) 2  ) ) () 
    $endif
    $endif
    $call readSDHCRegisters (36  ) (presentStateVal ) 
    $volatile commandInhibit_CMD := ((presentStateVal [] 0 ) == 0 ) $buffering 1
    $volatile addresscheck := (((address + 3 ) == _h0f ) & b0) $buffering 1
    $volatile presentState := ((presentStateVal >> 1 ) << 1 ) $buffering 1
    $if (addresscheck & commandInhibit_CMD) $then 
    $volatile tempPresentStateHere := (presentState | _h01 ) $buffering 1
    $call writeSDHCRegisters (36  tempPresentStateHere ) () 
    dataRxEnrty1 := ZERO_1 $buffering 1// bits of buffering = 1. 
    dataRxEnrty2 := ZERO_1 $buffering 1// bits of buffering = 1. 
    $merge $entry waitloopforready 
    $endmerge
    waitReady := ready $buffering 1// bits of buffering = 1. 
    $if (waitReady == ZERO_1) $then 
    $place[waitloopforready]
    $endif
    $merge $entry waitloopfor8clocks 
    $endmerge
    waitReady8clocks := ready8clocks $buffering 1// bits of buffering = 1. 
    $if (waitReady8clocks == ZERO_1) $then 
    $place[waitloopfor8clocks]
    $endif
    readyClockCountEnable := ZERO_1 $buffering 1// bits of buffering = 1. 
    $call command_generator () (normalInterruptStatusVar1 normalInterruptStatusVar2 errorInterruptStatusVar1 errorInterruptStatusVar2 dataErrorInterruptStatusVar1 dataTransferComplete ) 
    readyClockCountEnable := ONE_1 $buffering 1// bits of buffering = 1. 
    normalInterruptFlag1 := _hFF  $buffering 1// bits of buffering = 8. 
    normalInterruptFlag2 := _hFF  $buffering 1// bits of buffering = 8. 
    errorInterruptFlag1 := _hFF  $buffering 1// bits of buffering = 8. 
    errorInterruptFlag2 := _hFF  $buffering 1// bits of buffering = 8. 
    $endif
    $if (rxBufferPointer > 0 ) $then 
    $call readSDHCRegisters (37  ) (tempPresentState_1_1 ) 
    $call writeSDHCRegisters (37  (tempPresentState_1_1 | _h08 ) ) () 
    bufferReadReady := (ZERO_8 | _h20 ) $buffering 1// bits of buffering = 8. 
    normalInterruptFlag1 := (normalInterruptFlag1 | _h20 ) $buffering 1// bits of buffering = 8. 
    $endif
    $if (txBufferPointer < 512 ) $then 
    $call readSDHCRegisters (37  ) (tempPresentState_1_2 ) 
    $call writeSDHCRegisters (37  (tempPresentState_1_2 | _h04 ) ) () 
    bufferWriteReady := (ZERO_8 | _h10 ) $buffering 1// bits of buffering = 8. 
    normalInterruptFlag1 := (normalInterruptFlag1 | _h10 ) $buffering 1// bits of buffering = 8. 
    $endif
    $volatile bufferDataPortCheck := (address == 32 ) $buffering 1
    $if ((bufferDataPortCheck == 1 ) & (txBufferPointer < 512 )) $then 
    $merge $entry loopBuffer 
    $phi B := 				  ($bitcast ($uint<8>) 0  ) $on   $entry 				  next_B $on   loopBuffer 
    // type of target is $uint<8>
    $endmerge
    $call readSDHCRegisters ((32  + B) ) (tempBuf ) 
    dataBufferTx := tempBuf $buffering 1// bits of buffering = 8. 
    $volatile next_B := (B + 1 ) $buffering 1
    $if (next_B < 4 ) $then 
    $place[loopBuffer]
    $endif
    txBufferPointer := (txBufferPointer + 4 ) $buffering 1// bits of buffering = 10. 
    $if (txBufferPointer == 512 ) $then 
    $call readSDHCRegisters (37  ) (tempPresentState_1_3 ) 
    $call writeSDHCRegisters (37  (tempPresentState_1_3 | _hfb ) ) () 
    $call readSDHCRegisters (12  ) (transferRegVal ) 
    singleMultipleBlock := (  $bitreduce |  (transferRegVal & _h20 ) ) $buffering 1// bits of buffering = 1. 
    blockCountEnable := ((  $bitreduce |  (transferRegVal & _h02 ) ) & singleMultipleBlock) $buffering 1// bits of buffering = 1. 
    $merge $entry loopBlock 
    $phi C := 				  ONE_8 $on   $entry 				  next_C $on   loopBlock 
    // type of target is $uint<8>
    $phi newBlockCount := 				  ($bitcast ($uint<16>) 0  ) $on   $entry 				  blockCount $on   loopBlock 
    // type of target is $uint<16>
    $endmerge
    $call readSDHCRegisters ((6  + C) ) (newBlockCountTemp ) 
    $volatile blockCount := (( $slice newBlockCount 7 0 )  && newBlockCountTemp) $buffering 1
    $volatile next_C := (C - 1 ) $buffering 1
    $if (C != 0 ) $then 
    $place[loopBlock]
    $endif
    $volatile blockCountTrue := (blockCount == 1 ) $buffering 1
    $volatile lastBlock := (( ~ singleMultipleBlock ) | (blockCountEnable & blockCountTrue)) $buffering 1
    $call dataTx (lastBlock blockCountEnable blockCount ) (blockCountNext transferComplete ) 
    $call writeSDHCRegisters (7  ( $slice blockCountNext 15 8 )  ) () 
    $call writeSDHCRegisters (6  ( $slice blockCountNext 7 0 )  ) () 
    normalInterruptFlag1 := (normalInterruptFlag1 | _h02 ) $buffering 1// bits of buffering = 8. 
    errorInterruptFlag1 := (errorInterruptFlag1 | _h60 ) $buffering 1// bits of buffering = 8. 
    $endif
    $endif
    $else 
    $volatile readBufferDataPortCheck := (address == 32 ) $buffering 1
    $if ((readBufferDataPortCheck == 1 ) & (rxBufferPointer != 0 )) $then 
    $merge $entry loopBufferWrite 
    $phi D := 				  ($bitcast ($uint<8>) 0  ) $on   $entry 				  next_D $on   loopBufferWrite 
    // type of target is $uint<8>
    $endmerge
    tempBuf2 := dataBufferRx $buffering 1// bits of buffering = 8. 
    $call writeSDHCRegisters ((32  + D) tempBuf2 ) () 
    $volatile next_D := (D + 1 ) $buffering 1
    $if (next_D < 4 ) $then 
    $place[loopBufferWrite]
    $endif
    rxBufferPointer := (rxBufferPointer - 4 ) $buffering 1// bits of buffering = 10. 
    $call readSDHCRegisters (12  ) (transferRegVal2 ) 
    singleMultipleReadBlock := (  $bitreduce |  (transferRegVal2 & _h20 ) ) $buffering 1// bits of buffering = 1. 
    $if (rxBufferPointer == 0 ) $then 
    $call readSDHCRegisters (37  ) (tempPresentState_1_4 ) 
    $call writeSDHCRegisters (37  (tempPresentState_1_4 & _hf7 ) ) () 
    $if (singleMultipleReadBlock == 1 ) $then 
    readBlockCountEnable := ((  $bitreduce |  (transferRegVal2 & _h02 ) ) & singleMultipleBlock) $buffering 1// bits of buffering = 1. 
    $merge $entry loopBlock2 
    $phi E := 				  ONE_8 $on   $entry 				  next_E $on   loopBlock2 
    // type of target is $uint<8>
    $phi readNewBlockCount := 				  ($bitcast ($uint<16>) 0  ) $on   $entry 				  readBlockCount $on   loopBlock2 
    // type of target is $uint<16>
    $endmerge
    $call readSDHCRegisters ((6  + E) ) (readnewBlockCountTemp ) 
    $volatile readBlockCount := (( $slice readNewBlockCount 7 0 )  && readnewBlockCountTemp) $buffering 1
    $volatile next_E := (E - 1 ) $buffering 1
    $if (E != 0 ) $then 
    $place[loopBlock2]
    $endif
    readBlockCountTrue := (readBlockCount == 1 ) $buffering 1// bits of buffering = 1. 
    readLastBlock := (readBlockCountEnable & readBlockCountTrue) $buffering 1// bits of buffering = 1. 
    $if (readBlockCount != 0 ) $then 
    newReadBlockCount := (readBlockCount - 1 ) $buffering 1// bits of buffering = 16. 
    $call dataRx (readLastBlock ) (dataErrorInterruptStatusVar ) 
    dataRxEnrty1 := ZERO_1 $buffering 1// bits of buffering = 1. 
    dataRxEnrty2 := ONE_1 $buffering 1// bits of buffering = 1. 
    $call writeSDHCRegisters (7  ( $slice newReadBlockCount 15 8 )  ) () 
    $call writeSDHCRegisters (6  ( $slice newReadBlockCount 7 0 )  ) () 
    readDataTransferComplete := ( $mux readLastBlock ($bitcast ($uint<8>) 2  )  ZERO_8 )  $buffering 1// bits of buffering = 8. 
    normalInterruptFlag1 := (normalInterruptFlag1 | _h02 ) $buffering 1// bits of buffering = 8. 
    errorInterruptFlag1 := (errorInterruptFlag1 | _h60 ) $buffering 1// bits of buffering = 8. 
    $endif
    $endif
    $endif
    $endif
    $call readSDHCRegisters ((address + 0 ) ) (readTemp3 ) 
    $call readSDHCRegisters ((address + 1 ) ) (readTemp2 ) 
    $call readSDHCRegisters ((address + 2 ) ) (readTemp1 ) 
    $call readSDHCRegisters ((address + 3 ) ) (readTemp0 ) 
    readdata3 := ( $mux b3 readTemp3  ZERO_8 )  $buffering 1// bits of buffering = 8. 
    readdata2 := ( $mux b2 readTemp2  ZERO_8 )  $buffering 1// bits of buffering = 8. 
    readdata1 := ( $mux b1 readTemp1  ZERO_8 )  $buffering 1// bits of buffering = 8. 
    readdata0 := ( $mux b0 readTemp0  ZERO_8 )  $buffering 1// bits of buffering = 8. 
    sdhc_to_peripheral_bridge_response := ((readdata3 && readdata2) && (readdata1 && readdata0)) $buffering 1// bits of buffering = 32. 
    $endif
    dataErrorInterruptStatus := ((( $mux dataRxEnrty1 dataErrorInterruptStatusVar1  _b0  )  | ( $mux dataRxEnrty2 dataErrorInterruptStatusVar  _b0  ) ) | ( $mux (( ~ dataRxEnrty1 ) & ( ~ dataRxEnrty2 )) ZERO_8  _b0  ) ) $buffering 1// bits of buffering = 8. 
    sdhcRegisters[50 ] := (((sdhcRegisters[50 ] | (dataErrorInterruptStatus | errorInterruptStatusVar1)) & errorInterruptFlag1) & sdhcRegisters[54 ]) $buffering 1// bits of buffering = 8. 
    $merge $entry loopError 
    $phi S := 			  ONE_8 $on   $entry 			  next_S $on   loopError 
    // type of target is $uint<8>
    $phi readErrorInterruptReg := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  errorInterruptReg $on   loopError 
    // type of target is $uint<16>
    $phi readErrorInterruptEnableReg := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  errorInterruptEnableReg $on   loopError 
    // type of target is $uint<16>
    $phi readErrorInterruptSignalEnableReg := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  errorInterruptSignalEnableReg $on   loopError 
    // type of target is $uint<16>
    $phi readNormalInterruptEnableReg := 			  ($bitcast ($uint<16>) 0  ) $on   $entry 			  normalInterruptEnableReg $on   loopError 
    // type of target is $uint<16>
    $endmerge
    $call readSDHCRegisters ((50  + S) ) (errorInterruptRegTemp ) 
    $volatile errorInterruptReg := (( $slice readErrorInterruptReg 7 0 )  && errorInterruptRegTemp) $buffering 1
    $call readSDHCRegisters ((54  + S) ) (errorInterruptEnableRegTemp ) 
    $volatile errorInterruptEnableReg := (( $slice readErrorInterruptEnableReg 7 0 )  && errorInterruptEnableRegTemp) $buffering 1
    $call readSDHCRegisters ((58  + S) ) (errorInterruptSignalEnableRegTemp ) 
    $volatile errorInterruptSignalEnableReg := (( $slice readErrorInterruptSignalEnableReg 7 0 )  && errorInterruptSignalEnableRegTemp) $buffering 1
    $call readSDHCRegisters ((52  + S) ) (normalInterruptEnableRegTemp ) 
    $volatile normalInterruptEnableReg := (( $slice readNormalInterruptEnableReg 7 0 )  && normalInterruptEnableRegTemp) $buffering 1
    $call readSDHCRegisters ((44  + S) ) (clockControlRegTemp ) 
    $volatile next_S := (S - 1 ) $buffering 1
    $if (S != 0 ) $then 
    $place[loopError]
    $endif
    $volatile errorInterruptRegVal0 := ( $slice errorInterruptReg 7 0 )  $buffering 1
    $volatile errorInterruptRegVal1 := ( $slice errorInterruptReg 15 8 )  $buffering 1
    $volatile errorInterruptEnableVal0 := ( $slice errorInterruptEnableReg 7 0 )  $buffering 1
    $volatile errorInterruptEnableVal1 := ( $slice errorInterruptEnableReg 15 8 )  $buffering 1
    $volatile errorInterruptSignalEnableVal0 := ( $slice errorInterruptSignalEnableReg 7 0 )  $buffering 1
    $volatile errorInterruptSignalEnableVal1 := ( $slice errorInterruptSignalEnableReg 15 8 )  $buffering 1
    $volatile normalInterruptEnableVal0 := ( $slice normalInterruptEnableReg 7 0 )  $buffering 1
    $volatile normalInterruptEnableVal1 := ( $slice normalInterruptEnableReg 15 8 )  $buffering 1
    tempErrorReg0 := (((errorInterruptRegVal0 | (dataErrorInterruptStatus | errorInterruptStatusVar1)) & errorInterruptFlag1) & errorInterruptEnableVal0) $buffering 1// bits of buffering = 8. 
    tempErrorReg1 := (((errorInterruptRegVal1 | errorInterruptStatusVar2) & errorInterruptFlag2) & errorInterruptEnableVal1) $buffering 1// bits of buffering = 8. 
    $call writeSDHCRegisters (51  tempErrorReg1 ) () 
    errorInterruptBit := (((  $bitreduce |  tempErrorReg0 ) | (  $bitreduce |  tempErrorReg1 )) && ($bitcast ($uint<7>) 0  )) $buffering 1// bits of buffering = 8. 
    $volatile checkInterruptEnable := ((  $bitreduce |  normalInterruptEnableVal0 ) | (  $bitreduce |  normalInterruptEnableVal1 )) $buffering 1
    $if (checkInterruptEnable == 1 ) $then 
    interrupt := (((((readDataTransferComplete | dataTransferComplete) | transferComplete) | ((bufferReadReady | bufferWriteReady) | normalInterruptStatusVar1)) & normalInterruptEnableVal0) & normalInterruptFlag1) $buffering 1// bits of buffering = 8. 
    $call writeSDHCRegisters (48  interrupt ) () 
    $call writeSDHCRegisters (49  errorInterruptBit ) () 
    $call readSDHCRegisters (56  ) (tempNormalSignal ) 
    interruptLine := (tempNormalSignal & interrupt) $buffering 1// bits of buffering = 8. 
    errorInterruptLine := ((tempErrorReg0 & errorInterruptSignalEnableVal0) | (tempErrorReg1 & errorInterruptSignalEnableVal1)) $buffering 1// bits of buffering = 8. 
    SDHC_to_IRC_INT := ((  $bitreduce |  interruptLine ) | (  $bitreduce |  errorInterruptLine )) $buffering 1// bits of buffering = 1. 
    $else 
    $call writeSDHCRegisters (48  ZERO_8 ) () 
    SDHC_to_IRC_INT := ZERO_1 $buffering 1// bits of buffering = 1. 
    $endif
    $report (int check 		 dataErrorInterruptStatus dataErrorInterruptStatus 		 errorInterruptStatusVar1 errorInterruptStatusVar1 		 errorInterruptFlag1 errorInterruptFlag1 )
    $call readSDHCRegisters (44  ) (clockControlVal0 ) 
    $call readSDHCRegisters (45  ) (clockControlVal1 ) 
    $volatile frequencyDivider := (( $slice clockControlVal0 7 6 )  && clockControlVal1) $buffering 1
    $if (frequencyDivider == 0 ) $then 
    frequencySelect := ($bitcast ($uint<20>) 2  ) $buffering 1// bits of buffering = 20. 
    $else 
    frequencySelect := (($bitcast ($uint<20>) frequencyDivider ) * 2 ) $buffering 1// bits of buffering = 20. 
    $endif
    $volatile tempclockcontroller := ((( $slice clockControlVal0 7 2 )  && clkStable) && (clockControlVal0 [] 0 )) $buffering 1
    $call writeSDHCRegisters (44  tempclockcontroller ) () 
    sdClkEnable := (tempclockcontroller [] 2 ) $buffering 1// bits of buffering = 1. 
    $place[loopback]
  }
}
// Memory space 0: dataErrorInterruptStatus 
// Memory space 1: dataRxEnrty1 
// Memory space 2: dataRxEnrty2 
// Memory space 3: errorInterruptFlag1 
// Memory space 4: errorInterruptFlag2 
// Memory space 5: normalInterruptFlag1 
// Memory space 6: normalInterruptFlag2 
// Memory space 7: rxBufferPointer 
// Memory space 8: sdhcRegisters 
// Memory space 9: txBufferPointer 
